---
title: "scDNA: R package for DNA+protein single cell DNA sequencing analysis"
author: "Michael Bowman and Bobby Bowman"
date: "8/15/2022"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
Install scDNA package.
```{r,message=FALSE,warning=FALSE,eval=FALSE}
library(devtools)
devtools::install_github("https://github.com/bowmanr/scDNA/tree/BB_dev",force=TRUE)
```
<<<<<<< Updated upstream


Start off by loading the scDNA package, and pointing the system to a h5 of interest. For speed purposes, I strongly suggest you have the file local as opposed to on the server. We have hosted the an example h5 on google drive for your convenience. The h5 file will be placed in your home directory, for this tutorial
```{r,packages}
=======
loading in necessary libraries

```{r,message=FALSE,echo=FALSE,eval=FALSE}
>>>>>>> Stashed changes
library(scDNA)
library(googledrive)
library(knitr)
```

```{r, file identificaiton,eval=FALSE}
drive_download(
  file="https://drive.google.com/file/d/1cy_9AZl3I9hT0RhdhQQZkI0ervM8EPeZ/view?usp=drive_link",
  path = "~/Sample1962.dna+protein.h5",
  overwrite = TRUE
)

```

We first read in the genotype matrix (NGT), and restrict the number of variants based on a bulk VAF of 0.05%, and requiring genotyping information (either mutant or WT) in at least 20% of the cells.   This is performed with the "read_tapestri_h5_NGT" function.  

```{r, NGT extraction,cache=TRUE}
file<- "~/Sample1962.dna+protein.h5"
NGT<-read_tapestri_h5_NGT(file,
                          VAF_cutoff = 0.05,
                          GT_cutoff = 10 )
```

The next step is to filter out genotypes which are low quality based on read depth (DP), genotype quality score (GQ), or inappropriate allele frequencies (AF).  For the AF parameter, we assume that a heterozygous call needs to posses an allele frequency between 20-80%.
```{r,cache=TRUE}
filtered_NGT<-quality_filter_NGT(file=file,
                                 NGT=NGT,
                                 DP_cut=10, 
                                 AF_cut=20,
                                 GQ_cut=20)
```

These data.frames will possess the same number of variants and cells, but the 'filtered_NGT' data.frame will contain many more NAs. The 'filtered_NGT' is transposed for downstream processing and more efficient computation. 
```{r, inspect NGT matrices}
#Dimensions
print(dim(NGT))
print(dim(filtered_NGT))

#Total number of NAs
print(table(is.na(NGT)))
print(table(is.na(filtered_NGT)))
```

Now that we have our filtered NGT matrix, we can go through and annotate variants of interest.  Here I have constructed a manually curated 'annotation_key.csv' file containing ccds_id's for each gene to denote the transcript of interest. I also made a limited txDB object for these genes so we do not need to query the entire genome. This expedites processing time. Future updates will show the details for constructing your own. 
```{r,variant selection setup,message=FALSE,warning=FALSE,cache=TRUE}
library(VariantAnnotation)
library(GenomicRanges)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(magrittr)
library(AnnotationDbi)
library(dplyr)
library(pals)
library(tidyr)
library(tidyverse)
annotation_key<-read.csv("annotation_key.csv")
hg19refseq_txdb<-loadDb("hg19refseq_txdb.sqlite")
banned<-read.csv("banned_list.csv")[,1]

annotation_key%<>%inner_join(VariantAnnotation::select(hg19refseq_txdb,
                                    keys=annotation_key$ccds_id,
                                    columns=c("TXID","TXNAME"),
                                    keytype = "TXNAME"),
                             by=c("ccds_id"="TXNAME"))%>%
                  mutate(TXID=as.character(TXID))
```

Now we can use the 'annotate_variants' function from the 'scDNA' package.
```{r, annotate variants,message=FALSE,warning=FALSE}
final_mutation_info<- annotate_variants(file=file,
                             annotation_key=annotation_key,
                             txdb=hg19refseq_txdb,
                             banned=banned,
                             NGT=filtered_NGT)

final_mutation_info%>%
                arrange(desc(Bulk_VAF))%>%
                dplyr::select(AA,Bulk_VAF,GT_call_rate,id)%>%
                head(n=10)
```

The above annotates all mutations greater than bulk VAF cutoff established when reading in the first NGT file. This bulk VAF is computed in cells for which the variant was successfully genotyped, so if a successful genotype is only found in 10 cells, you can get a VAF of 20% with only 2 mutant cells.  Hence the 'GT_call_rate' is critical to keep in mind here.  

From here, we can go in two directions here.  For samples selected with specific variants of interest, we can pick them out precisely.  For a "discovery mode" we can pass a reasonable set of rules. We can also use these in concert for a hybrid approach.

Here we will search for specific variants we expect to find this sample based on bulk sequencing.
```{r}

required_variants<- final_mutation_info%>%
                        dplyr::filter(grepl("RAS|NPM1.2|TET",AA))%>%
                        dplyr::filter(Bulk_VAF>2&GT_call_rate>15)%>%
                        dplyr::filter(CONSEQUENCE%in%c("nonsynonymous","frameshift","nonsense"))%>%
                        dplyr::select(id,Bulk_VAF,GT_call_rate,AA)%>% #break here to observe full table with mutation information of interest
                        pull(id)
```

We can then ask which cells possess complete genotyping information for these critical variants. We want to retain these cells throughout all future analyses and refer to them as "required_cells".
```{r ,message=FALSE,warning=FALSE}
required_cells<-filtered_NGT%>%dplyr::select(Cell,tidyselect::all_of(required_variants))%>%
                    dplyr::filter(across(.cols = !Cell,.fns = ~ !is.na(.x)))%>%
                    pull(Cell)
```


What other variants could we also look into without losing too many of these required cells? We might be interested in seeing if there are other variants that are well represented amongst these required variants. We will focus on non-synonymous mutations that are not in introns for this vignette.
```{r}
coding_variants<- final_mutation_info%>%
                        dplyr::filter(!grepl("intronic",AA))%>%
                        dplyr::filter(CONSEQUENCE!="synonymous")%>%
                        dplyr::filter(GT_call_rate>10)%>%
                        dplyr::filter(Bulk_VAF>0.5)%>%
                        dplyr::select(id,Bulk_VAF,GT_call_rate,AA)%>% #break here to observe full table with mutation information of interest
                        pull(id)

mut_info_annotated<-filtered_NGT%>%
                          pivot_longer(cols=-Cell,names_to="id",values_to = "NGT")%>% #transform length wise
                          dplyr::filter(!is.na(NGT))%>% #remove poor genotyping calls
                          dplyr::filter(id%in%coding_variants)%>% #select variants of interest
                          group_by(id)%>% #split data.frame into groups based on the variants of interest variants
                          summarise(required_cell_ratio = mean(all_of(required_cells)%in%Cell))%>% # calculate the proportion of required cells represnted in successfully genotyped cells for that variant
                          arrange(desc(required_cell_ratio))%>% # order the data.frame, helpful for pltting later
                          inner_join(final_mutation_info)%>% # join with mutation info
                          dplyr::filter(!grepl("intronic",AA))%>%  #removes duplicate transcripts
                          mutate(id=factor(id,levels=c(id)))%>% #helpful for pltting later
                          mutate(AA=factor(AA,levels=c(AA)))%>%  #helpful for pltting later
                          mutate(required=ifelse(id%in%required_variants,"Required","Other"))%>%
                          dplyr::select(id,required_cell_ratio,Bulk_VAF,GT_call_rate,AA,required)

```

Let's graphically look at these tables for some context
```{r,echo=TRUE,fig.align='center',fig.height=5,fig.width=5}
library(ggplot2)
<<<<<<< Updated upstream
library(RColorBrewer)
library(cowplot)
ggFraction<-ggplot(mut_info_annotated,aes(x=AA,y=required_cell_ratio,color=required))+
              geom_point()+
              theme_bw()+
              labs(y="Fraction of essential cells \n succesfully genotyped")+
              scale_color_manual(values=c("Required"=brewer.pal(5,"Reds")[5],
                                          "Other"="black"))+
              theme(axis.text.x=element_blank(),
                    axis.ticks.x = element_blank(),
                    axis.title.x = element_blank())

ggVAF<-ggplot(mut_info_annotated,aes(x=AA,y=Bulk_VAF,color=required))+
              geom_point()+
              theme_bw()+
              scale_y_log10()+
              labs(x="Variant",y="Computed bulk VAF")+
              scale_color_manual(values=c("Required"=brewer.pal(5,"Reds")[5],
                                          "Other"="black"))+
              theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1))

plot_grid(ggFraction,ggVAF,ncol=1,axis="lr",align="v",rel_heights=c(0.75,1))
```


For this matrix, we can filter out cells that are important to us with the function below.
```{r,message=FALSE,warning=FALSE}
complete_NGT<- filtered_NGT%>%  
                    dplyr::select(Cell,all_of(required_variants))%>%
                    dplyr::filter(Cell%in%required_cells)
print(dim(complete_NGT))
print(table(is.na(complete_NGT)))
```

There are likely quite a few cells which we can hope to gain information from though, albeit with lower quality information.  We can extract those too and mask them.  The function "active_NGT_filter" below is written for optimal extraction of meaningful cells from a wide range of variants.  Here we will simply restrict the filtering to the exact "required_variants" we are interested in.  You can think of the "variants_of_interest" argument below as a universe from which we could sample.
```{r,message=FALSE,warning=FALSE}
maximal_NGT<-scDNA::active_NGT_filter(filtered_NGT,
                                  variants_of_interest=required_variants,
                                  required_variants=required_variants,
                                  required_cells=required_cells,
                                  variant_score_cutoff=0.4,
                                  cell_score_cutoff=0.4,
                                  greedy_scalar=0.005)
```

In a different setting we might have included new variants than just our required ones, and as such we would want to update the variant information.  This is achieved below.
```{r}
final_variant_info <- mut_info_annotated%>%
                                dplyr::filter(id%in%(all_of(colnames(maximal_NGT))))%>%                       dplyr::select(id,required_cell_ratio,Bulk_VAF,GT_call_rate,AA)%>%
                                arrange(desc(Bulk_VAF))

```

We now have our complete_NGT (full of required_cells only), and our maximal_NGT where we may have low quality information.  Using the function below we can fill in the NA's in the maximal_NGT with that low quality info, and flag cells as either "Complete" or "Other" for downstream processing.
```{r,message=FALSE,warning=FALSE}
final_NGT<-generate_lowQC_matrix(file=file,
                                 complete_NGT=complete_NGT,
                                 NGT_to_fill=maximal_NGT)
```

Now we want to enumerate how many clones are present by identifying the abundance of genetically identical cells.  We use the following clone naming convention, where left to right reads in the order of bulk VAF, and each genotype is separated by an underscore ("_").  So a clone 1_0_1 would be heterozygous for the 1st and 3rd most abundant mutations, and WT for the 2nd most abundant.  This function returns a list with three slots: Clones, NGT, and Architecture.  The replicates argument is used to determine how many rounds of resampling should be performed to establish a 95% confidence interval on the abundance of a particular clone.
```{r}
final_sample_summary<-enumerate_clones(NGT=final_NGT,
                                       variant_metadata=final_variant_info,
                                       replicates = 500)
```

With the clones enumerated, we can now aggregate the median read depth, genotype quality and allele dropout per clone.  We overwrite this into the 'Clones' slot into the final_sample_summary object.  
```{r}
final_sample_summary$Clones<-clone_QC(final_sample_summary, file)
```

We can now look at a clonograph of the data
```{r,fig.align='center',fig.height=5,fig.width=5}
clonograph(final_sample_summary)
```

Based on this we can also select clones of interest either based on QC metrics, or by passing a string of clone names to the 'select exact' argument.  If you use the 'select_exact' argument, then the QC metrics willbe ignored.
```{r}
final_sample_summary_subset<-select_clones(final_sample_summary,
                                            ADO_cut=0.10,
                                            GQ_cut=30,
                                            DP_cut=10,
                                            select_exact=FALSE)
```

Here we see a cleaned up clongraph.
```{r,fig.align='center',fig.height=5,fig.width=5}
clonograph(final_sample_summary_subset)
```

We can also strip out the "Other" cells and only focus on those with complete genotype data.  As of now, we lose the confidence intervals when we subset this way.
```{r,fig.align='center',fig.height=5,fig.width=5}
clonograph(final_sample_summary_subset,complete_only = TRUE)
```

Now we will demonstrate how to export the protein data to Seurat for clustering, and producing a UMAP. We also demonstrate our wrapper to normalize protein data with either CLR (base Seurat) or dsb if you have IGg controls. Coming soon, our own normalization method for protein information! Stay tuned!
```{r,message=FALSE,warning=FALSE,cache=TRUE,fig.align='center',fig.height=5,fig.width=5}
protein_mat_final<-read_tapestri_h5_protein(file=file)%>%
                          dplyr::filter(Cell%in%final_sample_summary_subset$NGT$Cell)
  
metadata<- extract_droplet_size(file,
                                final_sample_summary=final_sample_summary_subset)
=======

```


Start off by loading the scDNA package, and pointing the system to a h5 of interest. For speed purposes, I strongly suggest you have the file local as opposed to on the server. Change the folder path below to the match where you have placed the Sample1962.dna+protein.h5 file.

```{r load in file,eval=FALSE}
sample_file<- "~/CodingCamp/Projects/scDNA_demo/Sample1962.dna+protein.h5"
#sample_file<-c("/Users/bowmanrl/Desktop/Review/MSK24.cells.loom")
```


First, we read in the h5 file to generate the variant outputs we seek. This function has 2 forms: 1) an exploratory phase, and a 2) refinement phase. These two phases are determined by 2 cutoff parameters in the function. The GT_cutoff is the fraction of cells that are successfully genotyped for initial filtering. The VAF_cutoff is the variant allele frequency cutoff and is the fraction of cells that are mutated for initial filtering of variants (as a percent so a value of 12 means 12%). 

To ensure the exploratory phase is used, set the GT_cutoff=0, and VAF_cutoff=0. This will produce all possible variants that may be of interest, disregarding quality of the cells. The refinement phase is used after we have ID-ed variants of interest and allows for quality control on the cells of expressing those variants. We recommend that to start with an exploratory phase first before jumping right to the refinement phase (GT_cutoff=35 and VAF_cutoff=5). 

The variant_outputs will tell you the Variant ID, along with the number of cells that are called wildtype, heterozygous, homozygous, or we can't tell and it is labeled as Missing. Along with the genotyping_rate for the calls.

The variants are annotated from nucleotide positions on the chromosomes to their standard gene nomenclature, then these are joined together into a single data frame. Afterwards, you can find the genes you are interested in. An exmaple of pulling out out 3 genes, and plotting the Genotyping rate vs the Variant Allele Frequency (VAF) for all cells. This is an essential transition point from the exploratory phase to the refinement phase. 

```{r variant identification,eval=FALSE}
#need to install SpareMatrixStats
variant_output<-variant_ID(file=sample_file,
                           txdb="MSK_RL",
                            GT_cutoff=0,
                             VAF_cutoff=0)


genes_of_interest <- c("IDH2","NRAS","NPM1","TET2","FLT3","IDH1")
```


Using the above plot can help in determining which variants we should gain further insight into.
As an example, we are looking for heterozygous mutations (near the 50% VAF), with good quality 
genotyping rate. The following is how to filter the table to reduce the table to variants of interest.
```{r variant selection orders,fig.align='center',fig.height=5,fig.width=5,eval=FALSE}
variants_of_interest<-variant_output%>%
                        distinct()%>%
                          dplyr::filter(Class=="Exon")%>%
                          dplyr::filter(VAF>0.01)%>%
                          dplyr::filter(genotyping_rate>85)%>%
                          dplyr::filter(!is.na(CONSEQUENCE)&CONSEQUENCE!="synonymous")%>%
                          dplyr::filter(SYMBOL%in%genes_of_interest)%>%   
                          dplyr::arrange(desc(VAF))%>%
                          dplyr::slice(c(1,2,3))

```


Now that we have variants of interest we want to explore further, more stringent gates are devised 
to pull out "good" quality cells to explore. In this case, we increase the genotyping quality 
(so there are less Missing counts compared to actually good calls). The other gating parameters are
Depth read (DP_cutoff) which is the minimum number of reads necessary for a reliable genotype call in a single cell,
the Allele Frequency bandpass filter (AF_cutoff) which is the deviation from 0, 50, or 100% 
for a reliable call of WT, Het or Hom respectively. The last gating is the genotyping quality for indiviudal cells (GQ_cutoff)
which is the minimum genotype quality necessary for a reliable genotype call.
Afterwards this is put into a SingleCellExperiment object to standardize the data format
for the rest of our package or to be used by others such as Suerat or dsb.
```{r sce construction,cache=TRUE,eval=FALSE}
sce<-tapestri_h5_to_sce(file=sample_file,
                      variant_set = variants_of_interest,
                      GT_cutoff=90, 
                      VAF_cutoff=0.01,
                      DP_cutoff=10,
                      GQ_cutoff=20,
                      AF_cutoff=20)
```


This produces SingleCellExperiment object. Updates clones in the metadata for the quality check.


```{r,eval=FALSE}
sce<-enumerate_clones(sce, replicates = 500)
sce<-compute_clone_statistics(sce)
```

We can now look at a clonograph of the data, select a subset of clones and plot another clonograph
```{r clonograph,fig.align='center',fig.height=5,fig.width=5,eval=FALSE}
clonograph(sce)
```

```{r subset clonograph,fig.align='center',fig.height=5,fig.width=5,eval=FALSE}
sce_subset<-select_clones(sce,
                          ADO_cut=0.10,
                          GQ_cut=30,
                          DP_cut=10,
                          select_exact=FALSE)
clonograph(sce,complete_only=TRUE)
```
##Reinforcement Learning Trajectory Analysis

After developing the clonograph, there are two routes to for further analysis:
1) Trajectory Analysis of possible mutation order and cohort summarization,
2) Protein analysis for cell type identification.

First we will discuss the trajectory analysis, then we will discuss protein analysis. The following function uses the trajectory_analysis function which finds a few different trajectories we can explore.

```{r,eval=FALSE}
library(compiler)
library(foreach)
library(doParallel)
library(visNetwork)
library(igraph)
#enableJIT(3)
sce<-trajectory_analysis(sce)
start_state ="0_0_0" # Change based on problem and number of variants we are using
goal_state = "1_1_1" # Change based on problem and number of varianrs we are using``
```

```{r,eval=FALSE}
sce<-get_own_path(sce,start_state,goal_state)
visualize_any_optimal_path(sce,start_state,goal_state)

print(sce@metadata$Trajectories$WT_to_last_possible_clone)

```


```{r Visualize Whole Network,eval=FALSE}
vis_full_net<-visualize_full_network(sce)
vis_full_net
```

```{r visualize most likely order,fig.align='center',fig.height=5,fig.width=5,eval=FALSE}
vis_best_WT_to_dominant_clone<-visualize_WT_dominant_clone(sce)
vis_best_WT_to_dominant_clone
print(sce@metadata$Trajectories$WT_to_dominant_clone)
```
All paths from WT to dominant clone:
```{r visual all possible orders,fig.align='center',fig.height=5,fig.width=5,eval=FALSE}
vis_all_WT_to_dominant_clone<-visualize_all_WT_dominant_clone(sce)
vis_all_WT_to_dominant_clone
print(sce@metadata$Trajectories$All_WT_to_dominant_clone)

```

given user defined state, find where it can go with the clonograph
this is done by setting observed states variable equal to the ones that are observed in our dataframe.

```{r match clonal graph from WT,fig.align='center',fig.height=5,fig.width=5,eval=FALSE}
given_state <-"0"
match_clonal_graph(sce,given_state)
print(sce@metadata$Trajectories$WT_to_Observed_paths)

```


##Protein
Now we will demonstrate how to export the protein data to Seurat for clustering, and producing a UMAP. We also demonstrate our wrapper to normalize protein data with either CLR (base Seurat) or dsb if you have IGg controls. Coming soon, our own normalization method for protein information! Stay tuned!
```{r,message=FALSE,warning=FALSE,eval=FALSE}
library(dsb) 
library(Seurat)
library(SingleCellExperiment)
droplet_metadata<- extract_droplet_size(sample_file,sce=sce_subset)
>>>>>>> Stashed changes

# Try changing bins=1000 to see overlap empty droplets and real ones
ggplot(metadata, aes(x = dna_size, y = protein_size,color=Droplet_type )) +
                  theme_bw() + 
                  geom_density_2d(bins=1000)+
                  geom_hline(yintercept =c(1.5,5),lty=2)+
                  geom_vline(xintercept =c(0.1,1.5),lty=2)
```

After obtaining the protein matrix, we now want to extract background cells and normalize the protein. Both strategies to normalize the data are shown below.

<<<<<<< Updated upstream
```{r,message=FALSE,warning=FALSE}
library(dsb) 
library(Seurat)
```

```{r,cache=TRUE}
background_droplets<-metadata%>%
=======
```{r,message=FALSE,warning=FALSE,eval=FALSE}
background_droplets<-droplet_metadata%>%
>>>>>>> Stashed changes
                          dplyr::filter(Droplet_type=="Empty")%>%
                          dplyr::filter(dna_size<1.5&dna_size>0.15)%>%
                          pull(Cell)
```

<<<<<<< Updated upstream
```{r,cache=TRUE}
normalized_protein_mat_dsb<-normalize_protein_data(file=file,
                                         metadata=metadata,
                                         protein_mat=protein_mat_final,
                                         method="dsb",
                                         detect_IgG=TRUE,
                                         background_droplets=background_droplets)
```

```{r,cache=TRUE}
normalized_protein_mat_CLR<-normalize_protein_data(file=file,
                                          metadata=metadata,
                                           protein_mat=protein_mat_final,
                                           method="CLR",
                                           detect_IgG=FALSE,
                                          background_droplets=background_droplets)

final_metadata<- metadata%>%
                        dplyr::filter(Cell%in%colnames(normalized_protein_mat_CLR))%>%
                        dplyr::arrange(match(Cell,colnames(normalized_protein_mat_CLR)))
=======
sce<-normalize_protein_data(file=sample_file,
                             metadata=droplet_metadata,
                             sce=sce_subset,
                             method=c("dsb","CLR"),
                             detect_IgG=TRUE,
                             background_droplets=background_droplets)
>>>>>>> Stashed changes

```
```{r,eval=FALSE}
library(Biobase)
library(flowCore)
library(flowViz)
names(assays(altExp(sce)))
fcs_export(sce,
           slot="CLR_norm",
           save_path="/Users/bowmanrl/Desktop/sample_CLR.fcs")
```
Now we want to load in our data into Seurat. Keep in mind which normalization method for protein was used above. Comment out the one you do not want to use (or let it use CLR as it will currently overwrite the dsb one). Below follows the standard Seurat implementation where you apply nearest neighbor search, generate clusters, and build a UMAP. Afterwards, are some examples of further data exploration and plots to analyze your results.

<<<<<<< Updated upstream
```{r,message=FALSE,warning=FALSE,cache=TRUE,fig.align='center',fig.height=5,fig.width=5}
s <- CreateSeuratObject(counts=normalized_protein_mat_CLR, 
                        assay="Protein")
=======
```{r,message=FALSE,warning=FALSE,eval=FALSE}
library(Seurat)
>>>>>>> Stashed changes

s <- AddMetaData(object = s,
                 metadata = list("Clone"=final_metadata%>%pull("Clone"),
                                  "dna_size"=final_metadata%>%pull("dna_size"),
                                  "amplicons"=final_metadata%>%pull("amplicons"),
                                  "protein_size"=final_metadata%>%pull("protein_size"),
                                  "Group"=final_metadata%>%pull("Group"),
                                  "Tet2"=final_metadata%>%pull("chr4:106196213:C/T"),
                                  "Npm1"=final_metadata%>%pull('chr5:170837543:C/CTCTG'),
                                  "Nras"=final_metadata%>%pull('chr1:115258748:C/G')))

# cluster and run umap (based directly on dsb normalized values without isotype controls)
prots <- rownames(s@assays$Protein@data)[2:42]
s <- FindNeighbors(object = s, dims = NULL, assay = 'Protein', 
                  features = prots, k.param = 30, verbose = FALSE)

# direct graph clustering 
s <- FindClusters(object = s, resolution = 1, algorithm = 3, graph.name = 'Protein_nn', verbose = FALSE)

# umap for visualization only; (this is optional)
s = RunUMAP(object = s, assay = "Protein", features = prots, seed.use = 1990,
            min.dist = 0.2, n.neighbors = 50, verbose = FALSE)

<<<<<<< Updated upstream
DimPlot(s,reduction = "umap")

all.markers <-FindAllMarkers(s,test.use="roc")

FindMarkers(s,ident.1="1",ident.2="2")
VlnPlot(s,features=c("CD14"),  pt.size = 0.5)
Idents(object = s) <- "seurat_clusters"


FeaturePlot(s,features = c("CD34","CD117"),keep.scale = "feature")&
            colorspace::scale_color_continuous_divergingx(palette = 'RdBu', 
                                                          rev=TRUE,
                                                          na.value = "grey80")


data_out<-table(s@meta.data$Protein_nn_res.1,s@meta.data$Clone)%>%
                          data.frame%>%
                          group_by(Var2)%>%
                          mutate(Ratio=Freq/sum(Freq))
ggplot(data_out,aes(x=Var1,y=Var2,size=Ratio,color=Ratio))+geom_point()
ggplot(data_out%>%summarise(Total=sum(Freq)),aes(x=Total,y=Var2))+geom_col()
```


```{r,message=FALSE,warning=FALSE,fig.align='center',fig.height=5,fig.width=5}
DotPlot(s, features = c(all.markers%>%dplyr::filter(cluster=="1")%>%pull(gene))[1:8]) + RotatedAxis()
RidgePlot(s,features= c("CD117","CD14","CD11b","CD34","CD138")) 
DoHeatmap(s,slot="data", features = c("CD45RA","CD34","CD11b","CD14"),disp.max = 4)
```

These are some more evaluation plots for median protein expression 
```{r,message=FALSE,warning=FALSE,fig.align='center',fig.height=5,fig.width=5}
# make results dataframe 
d = cbind(s@meta.data, as.data.frame(t(s@assays$Protein@data)), s@reductions$umap@cell.embeddings)

# calculate the median protein expression separately for each cluster 
adt_plot = d %>% 
  dplyr::group_by(Protein_nn_res.1) %>% 
  dplyr::summarize_at(.vars = prots, .funs = median) %>% 
  tibble::remove_rownames() %>% 
  tibble::column_to_rownames("Protein_nn_res.1")


ggplot(d%>%
          dplyr::filter(Clone%in%c("0_0_0","1_0_0","1_1_0","1_0_1","1_1_1")), 
          aes(x =  `CD71`,y = CD45RA,color=Clone)) +
                  theme_bw() + 
                  facet_wrap(~Clone)+
                  geom_density_2d(contour_var = "ndensity")+
                #  geom_point()+
                  scale_color_viridis_d()# +
            #      geom_hline(yintercept =c(2.5),lty=2)+
              #    geom_vline(xintercept =c(),lty=2)
=======
DimPlot(s,reduction = "umap",group.by ="Clone" )

FeaturePlot(s,features = c("CD19"))
Idents(s)<-"Clone"
Seurat::FindMarkers(s,ident.1 = "0_0_0",ident.2 = "1_1_1")

Seurat::RidgePlot(s,features = "CD3")
>>>>>>> Stashed changes
```
